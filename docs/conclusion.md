# 6 Conclusion

## 6.1 Project Objective

The main objectives for this project where:

1. Create a scalable system for managing user accounts and inter-account interactions including matchmaking and friends.
2. Create a custom UDP protocol than implement key features required for game communication missing from vanilla UDP. These include reliability and security.

Both objectives have been met.

### 6.1.1 Objective One

The `server` package provides a method to manipulate the various account and inter-account rows from the database which in turn provides scalable storage of data. It additionally provides the necessary information required to find or create `Lobby`s.

The `client` package provides a user-friendly interface for interactions with the `Server`. Additionally, using the information provided by the `Server`, is able to matchmake by joining available lobbies, and only creating new ones where needed/requested.

### 6.1.2 Objective Two

The `udp` package defines the required `UDP` packets and implements their key features in the `udp.Client` and `udp.Server` communication.

### 6.1.3 Secondary Objectives

- Turn-based game demo
    - Implemented in the `rps` package.
- Real-time game demo
    - Omitted due to time constraints.
- Large packet size limit
    - Implemented in the `udp` package with the use of the `FRAG` flag.
- Authenticated Communication
    - Implemented in the `udp` package with the use of the `AUTH` packet containing a `X.509 Certificate`.
- Secure Communication
    - Implemented in the `udp` package with the use of the `ENCRYPT` flag.
- Reliable Communication
    - Implemented in the `udp` package with the use of the `RELIABLE` flag.
- Lightweight Communication
    - Implemented with the custom `UDP` protocol defined in `udp` which negates `TCP`'s overhead.
- Modularity
    - Implemented in the project's overall structure such that a game can be defined in a package.

## 6.2 Feature Evaluation

### 6.2.1 Reflection on Handshake Finished

The handshake `Finished` is generated by calculating a `Hash-based Message Authentication Code` (`HMAC`) using the session key. Though the `EC` keys used to generate the session key are ephemeral, the handshake exchange is still vulnerable to man-in-the-middle attacks. This could be mitigated by including some random int in each AUTH packet which is, in turn, included in the `Finished` `HMAC` calculation.

### 6.2.2 Port Selection and Assignment

The `Server` is responsible for selecting and assigning ports to any game servers it creates. The method for selection is rather rudimentary as the `Server` will just iterate from a given starting value indefinitely during run time. There are, therefore, no additional checks to validate either the availability (i.e. is the port is free) or suitability (e.g. within some reasonable range) of the port selected. A more advanced system could be implemented allowing for ports used by the `Server` to be monitored and released (e.g. by `LobbyHandler`) after use such that they could be reused.

### 6.2.3 Packet ERRORs

Though Packer ERRORs are raised during run time and then sent to the packet author, there is no mechanism in place to resend the packet. This would require a greater overhead as all recent packets would need to be stored such that they could be retired if a packet error occurred. This is ultimately outside of the scope of this project.

### 6.2.4 Automatic Game Importing

Though each game can be defined modularly using a package, the relevant game `Server` and `Client` must be explicitly imported into both the `server` and `client` packages. This limitation is largely due to the nature of `Python` imports and package structure. Some attempt could be made with the use of the underlying methods used by the `import` keyword but this would likely generate messy 'un-pythonic' code.

### 6.2.5 Congestion Control

Currently, the custom `udp` implements no congestion control. The use of a `Round-Time-Time` (`RTT`) could be used to artificially rate-limit a `Node`'s send rate. The `HEARTBEAT` packet contains an unused `data` field which would be a subtile candidate for transferring additional information about a `Node`'s network status.

### 6.2.6 Features Cut for Time

The `Scores` model and the highscore tracking functionality was ultimately abandoned due to time constraints. This feature could be implemented by returning the score values (already tracked by `Lobby` instances) and committing to the database.

Additionally, the stretch goal for a real-time game demo was never implemented. This would have been a more suitable demonstration of the efficiency of the `Packet` implementation but required far greater overhead for design and implementation than its turn-based counterpart.
